# Java集合

## 1. 说说Java中都有哪些集合？

Java中常用的集合有：

- List
- Set
- Map
- Queue

其中List和Set是属于Collection ， 而Map是对AbstractMap的实现。

### 1.1 List

List一般用来存储有序的数据。

List有多种实现，如：

- ArrayList
- LinkedList

#### 1.1.1 ArrayList

ArrayList的底层是使用数组来实现的。

优点：

- 使用数组实现，随机存取性能好。

缺点：

- 存储大小受到整形大小的限制。
- 删除数据需要对大量数据进行调整，消耗大
- 需要进行扩容，等维护操作。

#### 1.1.2 LinkedList

LinkedList底层使用链表实现

优点：

- 使用链表实现，删除数据效率高
- 无需扩容操作
- 理论上无存储上限

缺点：

- 随机存取效率低

### 1.2 Map

Map是一种以Key/Value方式存储数据的数据结构, 通过hash的方式把需要存储的数据映射到一个数组或者其他存储形式中, 其存取时间复杂度都是常数级别的.

Java中的Map大概有HashMap/Hashtable/TreeMap 等等.

其中HashMap 和HashTable中存储的数据是无序的,TreeMap中存储的数据是有序的

#### HashMap的内部实现

1. 首先, 最简单的来讲HashMap就是通过一个Hash函数来把Key映射到一个对应的下标上,然后将值存储到对应的位置

2. 冲突, 由于数组的长度是有限的,所以Hash函数映射的下标肯定会有发生冲突的情况 . 

   解决Hash冲突的办法有多种:

   1. 开放定址法
      1. 线性探测
      2. 再hash法
   2. 拉链法

   * 开放定址法就是当我们遇到hash冲突的情况的时候,我们可以寻找一个空闲的地址来存储数据.
     * 这个方法最大的优势就是相对于拉链法,开放定址法的数据都是存储在同一片内存空间中,内存使用更加紧凑.

   * 拉链法, 就是我的Hash空间存储的将不再是单独的一个值,而是一条链表,当出现冲突,直接在在链表头或者链表尾插入数据即可.

     * 拉链法的实现比起开放定址法更加简单 .

     在Java中HashMap采用的就是变种的拉链法. Java中的HashMap 在 一开始的时候是维护着一个链表的, 当链表的长度达到阈值的时候(默认是8) ,会将链表转化为红黑树, 用来稳定每次查找的复杂度. 

3. 为了减少Hash冲突的同时保证不浪费内存 ,HashMap一般都进行动态的扩容, 一般的,HashMap有一个确定的负载因子, 负载因子表示当前容器中存储的数据量和空间大小的比率, 当数据量达到负载因子的大小的时,会对HashMap进行扩容操作.

   在Java中, HashMap默认的容器大小为16 , 负载因子为0.75 . 当容器中的元素个数达到了阈值后, 会对容器进行扩容,每次扩容会将容器大小翻倍.

   在进行扩容后, 需要对已经存储的数据进行再hash 重新映射到新的容器中.

## 2 线程安全

### ConcurrentHashMap 内部实现

ConcurrentHashMap 是HashMap的线程安全实现 , ConcurrentHashMap 基本的实现还是和HashMap一样,通过Hash函数映射到容器中存储, 不过和HashMap不同的是ConcurrentHashMap的**容器是分成一段一段**的. 

当需要对ConcurrentHashMap中元素进行操作的时候, ConcurrentHashMap只会会对要操作的段进行加锁 ,这样就避免了而直接对全部进行加锁导致阻塞整个Map的操作 .

 

