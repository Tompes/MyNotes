# Redis相关问题

## 1. 什么是Redis？

* Redis是一个使用<mark>C语言</mark>编写的，<mark>非关系型</mark>数据库

* 其数据存储在<mark>内存</mark>中，读写性能优秀

* Redis提供了较为丰富的数据结构，能够胜任大多数任务场景

* 多用来做为缓存、数据库、和消息队列

## 2. Redis中有那些数据结构？

### 2.1. RedisObject 核心对象

1. string
   * string是最基础的key/value方式存储内容的一个数据结构
2. list
   * Redis中的list是一个双向链表，用来存储一些有序的数据
3. hash
   * 类似于java中的hashmap ,一般用来存储对象
4. set
   * 类似于java中的hashset, set中存储的都是无序的，唯一的数据
5. sortedset
   * 是一个有序的set

## 3 Redis 是单线程还是多线程？

最初Redis是单线程的，后来加入了多线程的支持。

Redis是基于Reactor 模型 实现了一个**IO多路复用程序**来管理多个连接，和一个事件管理器，用来处理事件。

通过这个机制它实现了使用单线程管理多个连接。

再者，多线程主要解决的是CPU的利用率的问题

## 4 Redis的持久化方法都有哪些？

### 4.1 快照模式（RDB）

 快照模式就是隔一段时把redis的内存空间中的数据整个复制拷贝到磁盘中。

这样做有一些优点：

* 占用空间相对可控
* 由于是直接保存的内存，所以恢复速度快

缺点也有：

* 每次保存都是一个全新的快照，这个过程很慢，实时性差

### 4.2 AOF（Append Only File）

AOF模式是维护一个文件，每次有新的对数据进行更改命令，就把这个命令以增量的方式添加到aof文件中去。恢复的时候只需要依次执行aof中的命令即可恢复数据。

优点：

* 实时性好，由于是增量式的持久化，可以做到秒级备份

缺点：

* 恢复速度慢
* 文件大小可能会很大，只能通过重写的方式类控制大小。

**重写**（AOF Rewrite）

当AOF文件达到一定的大小后，Redis会基于当前内存中的数据对AOF文件进行重写，从而降低AOF文件大小

## 5 Redis 缓存穿透/缓存击穿/缓存雪崩

### 5.1 缓存穿透

缓存穿透是指，请求的key在缓存中没有，同时在数据库中没有，这时候每次查询都会去访问数据库然后返回空。

解决办法：

* 为不存在的key设置缓存，比如设置为null或者其他表示为空的符号，然后为它设置一个较短的过期时间
* 使用布隆过滤器来进行判断key是否不存在于数据库中

### 5.2 缓存击穿

缓存击穿是指，请求的key在数据库中有，但是由于缓存失效了，没法命中缓存，这时候会直接去请求数据库。

解决办法：

* 在无法命中缓存的时候，只允许一个线程去数据库中拉取数据。
* 为热点数据设置永不过期。

### 5.3 缓存雪崩

缓存雪崩是指在同一时间段缓存大面积失效，大量请求直接访问数据库。

解决办法：

* 为热点数据设置为永不过期
* 设置两个冗余的redis服务，一个A设置过期时间，一个B不设置过期时间，通常去访问A,当遇到无法命中缓存时候去查B
* 或者在设置过期时间时不使用一个固定的值可以加上一个随机值

## 6. Redis 的过期删除

### 6.1 Redis如何知道一个数据过期了？

Redis中维护了一个叫做**过期字典**的数据空间，其类似于一个hash表，它的key是一个时间戳，value是在该时间过期的数据key

### 6.2 Redis过期数据删除策略？

Redis有两种过期数据删除策略：

1. 惰性删除
2. 定期删除

**惰性删除**：惰性删除就是在每次取出key的时候，我们才去去检查过期字典，然后删除过期数据

优点：

* CPU友好，消耗的CPU资源少

缺点：

* 可能会有很多已经过期的数据没有清除，造成空间浪费

**定期删除**：顾名思义，就是我们定时去检查过期字典，删除过期的数据

优点：

* 可以保证内存中数据大多数都是没有过期的，节省空间

缺点：

* 需要额外消耗CPU资源

## 7. Redis内存满了怎么办？

当出现内存不够用的情况了，Redis会执行预设的内存淘汰策略，来腾出空间

### 7.1 Redis的内存淘汰策略都有哪些？

Redis的内存淘汰策略分为两种：

1. **volatile** （对有设定过期时间的进行淘汰）

2. **allkeys**（对所有数据进行淘汰）

3. **no-eviction** （不对任何数据进行淘汰）

#### Volatile

volatile淘汰机制有：

1. volatile-lru （在设定有过期时间的数据中淘汰最长时间没有使用的数据）
2. volatile-lfu（在设定有过期时间的数据中淘汰最近使用频次最少的数据）
3. volatile-ttl （在设定有过期时间的数据中淘汰即将要过期的数据）
4. volatile-random（在设定有过期时间的数据中随即选择数据进行淘汰）

#### Allkeys

allkeys淘汰机制有：

1. allkeys-lru （在所有数据中选择最久没有使用的数据进行淘汰）
2. allkeys-lfu（在所有数据中选择使用频次最少的数据进行淘汰）
3. allkeys-random（在所有数据中随即选择数据进行淘汰）

## 8. Redis与数据库保持一致？

如果数据库中的数据发生了改变，但是redis中数据没有随之改变就会造成缓存和数据库数据不一致。

解决办法：

1. 延迟双删策略
2. 订阅数据库binlog

### 8.1 延迟双删

延迟双删策略：

1. 删除缓存数据
2. 写数据库
3. 设置延迟（如500ms）
4. 再次删除缓存数据

延迟双删策略是如何保证一致性的呢？

### 8.2 订阅binlog
