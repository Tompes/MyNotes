# MySQL相关

## 1. MySQL存储引擎

> MySQL中主流有两种存储引擎<mark>MyISAM</mark>和<mark>InnoDB</mark>

### 1.1 MyISAM

MyISAM 是MySQL5.5之前的默认存储引擎，其有以下特点：

1. 性能高
2. 支持全文检索
3. 最小支持表级锁
4. 不支持外键
5. 不支持事务
6. 不支持安全恢复

**有一种说法是应对读密集的应用场景更适合使用MyISAM**

### 1.2 InnoDB

InnoDB是MySQL5.5之后的默认存储引擎，其有以下特点：

1. 最初不支持全文检索，5.6后支持全文检索
2. 最小支持到行级锁
3. 支持外键
4. 支持事务
5. 支持安全恢复（事务日志redo（恢复）,undo（回滚））

## 2. MySQL中的索引

> 索引是一种数据结构，其存在就是为了加快查询效率，功用就像书的目录一样

> MySQL中的索引可以按照不同维度来解释

### 2.1 按照存储数据结构划分

#### 2.1.1 B+树索引

**B+树的特点**

* B+树是一个AVL自平衡查找树
  * 搜索树
  * 叶子节点拥有相同深度，叶节点的指针为空
  * 每层节点元素值从左到右递增
* 每个节点可以存储多个值
* 在叶子节点存储所有数据值，其他节点只存储索引
* 在叶子节点形成一条链表串联所有叶子节点

**优点**：

* 范围查找
* 严格平衡，高度更低
* 只有叶子结点存储数据，每个节点可以存储更多数据索引

**为什么B+树一般只有3～4层？**

* 够用了
* 层数太多会增加IO次数，影响性能。

#### 2.1.2 Hash索引

* 使用Hash表存储

优点：

* 查询速度快

#### 2.1.3 全文索引

### 2.2 按照应用层次来划分

#### 2.2.1 普通索引

一个只包含单列的索引为<mark>普通索引</mark>，一个表可以有多个单列索引

#### 2.2.2 唯一索引

约束索引列值必须为唯一的索引为<mark>唯一索引</mark>，允许空，在允许空时索引失效。

#### 2.2.3 复合索引

一个包含多个列的索引为<mark>复合索引</mark>

### 2.3 按照表记录排列顺序与索引顺序是否一致划分

#### 2.3.1 聚集索引

innodb的聚簇索引和data数据存储在一起，且表记录是按照索引的排序顺序来存储的。

在聚集索引中，一个聚集索引节点存储了所有的字段，使用聚集索引可以直接命中数据。

#### 2.3.2 非聚集索引

非聚集索引又叫二级索引，非聚集索引中存储着设定好的索引字段和对应的主键

查询非聚集索引会先查询到对应的聚集索引id然后去查询数据



## 3. MySQL中查询缓存的使用

### 3.1 MySQL查询缓存是什么？

> 查询缓存，顾名思义，是对MySQL中查询SQL语句对应的Query数据进行缓存的一个区域。

查询缓存是MySQL 中的一块特殊缓存区域，用来缓存``SELECT``语句的整个结果信息，**该缓存在表信息发生改变后缓存失效**。

过程如下：

SELECT 语句 -> Hash -> 查hash链表 -> 查到，拿到cache地址 -> 查不到，执行SQL并缓存 -> 返回结果

1. SELECT语句到达Server , Server对语句进行计算hash
2. 通过hash去查询MySQL查询缓存地址
3. 如果查到则直接返回，不用执行SELECT语句
4. 如果查不到，执行SELECT并将对应的数据存入缓存，当表信息发生改变失效

### 3.2 MySQL查询缓存机制规则

> MySQL查询缓存

1. **表任何数据或结构更改后，缓存失效，查询缓存中的值会被清空。**

   - Insert
   - Update
   - Delete
   - Truncate
   - Alter Table
   - Drop Table
   - Drop Database

2. **缓存的SQL语句<mark>严格区分大小写</mark>**

   由于使用``Hash映射``，所以缓存的SQL必须完全一致才能命中。

   ```sql
   SELECT * FROM T WHERE 1=1； -- SQL 1
   select * from T where 1=1； -- SQL 2
   -- SQL 2 不能命中 SQL 1 的缓存
   ```

3.  **查询缓存所有客户端共享**

   查询缓存通过session共享，一个client查询并缓存的结果，另一个客户端可以直接命中

4. **WHERE条件中如果包含不确定性参数或函数，不会被缓存**

   如：

   ```sql
   SELECT * FROM T WHERE fetch_date=current_date； -- 由于含有变量current_date，不会缓存
   ```

   

## 4. MySQL事务

### 4.1 MySQL事务特点

> ACID : 原子性、一致性、隔离性、持久性

#### A 原子性

原子性指的是同一事务中的操作，要么都执行成功，要么都不执行。

MySQL中的原子性是通过``undo log``来实现的

undo log 会把需要更改的数据存储起来，当出错时回滚

#### D 持久性

持久性是指事务提交后，数据是持久存在的，不会丢失。

#### I 隔离性

是指同一时间的多个事务之间是相互隔离的，使用MVCC实现

不同的隔离级别限制不一样。

* 读未提交
* 读提交
* 可重复读
* 串行化

#### C 一致性

一致性是指在同一事务中，前后读取到的数据要是一致的。

通过AID来保证一致性。

## 5. 事务并发中会出现的问题

### 5.1 脏读

脏读是指，事务读取到了其他事务未提交的修改，但是这个修改发生了回滚，导致事务拿到了错误的脏数据。

* ``事务1``将字段``name``从``大熊``修改为``胖虎`` 

* 此时``事务2``读取到字段``name``为``胖虎`` 
* 之后``事务1``发生``回滚``，``name``的值重新变为``大熊``
* 此时事务B拿到的数据便是脏数据。

```
事务1 ： 大熊 -> 胖虎 -> 大熊
事务2 ： -------|胖虎->...
```

**脏读只会出现在读未提交级别**

### 5.2 不可重复读

指在同一个事务中，前后查询到的同一个字段数据不一致。

* ``事务1``开始读取``name``字段为``静香``；

* 此时``事务2``，修改``name``字段为``小夫``，并commit提交了；
* 此时``事务1``再次读取``name``值，发现两次读取的数据不一致了。

**不可重复读发生在读未提交、读提交**

### 5.3 幻读

幻读是指同一个事务中，两次查找的数据条数不一样

### 5.4 丢失修改

事务1：A->B, 事务2：A->C ，事务1丢失修改

## 6. MySQL事务隔离级别

### 6.1 读未提交

即可以读到其他事务中还未提交的数据

### 6.2 读提交

读提交，只能读取到其他事务已经提交的数据

### 6.3 可重复读

在同一事务中，每次读取都是相同的

### 6.4 串行化

任何时候只有一个事务操作

## 7. MySQL中的锁

## 8. 如何解决幻读



## 8. 大表优化