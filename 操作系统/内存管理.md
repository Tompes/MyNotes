# 内存管理

## 1. 内存管理基础

> 内存管理，是操作系统5大基本职能之一。即操作系统需要对主存进行分配、共享、保护、扩张。

### 1.1 内存管理是做哪些事情？

1. **内存的分配和回收**
   * 由操作系统完成内存的分配和回收，使开发人员摆脱繁琐的内存分配回收问题，提高效率。
2. **地址转换**
   * 一般来说程序中使用的连续的逻辑地址，其和实习的物理地址是不一样的，需要由操作系统进行转换。
3. **内存扩张**
   * 利用虚拟存储技术（虚拟内存），来为程序提供大于物理内存的地址空间，从而在逻辑上实现扩容。
4. **内存保护**
   * 操作系统需要，对每个进程的地址空间进行保护，避免一个作业能够访问另一个作业的地址空间，造成隐患。

> **附：**
>
> #### 内存扩张的两种方式
>
> 1. 覆盖
>
>    分为固定区域和覆盖区域，长期活跃的放在固定区域，其他放在覆盖区域，当需要使用时，调入，并覆盖
>
> 2. 交换（Swap）
>
>    交换主要在不同作业之间进行，覆盖则是在同一个程序或进程中。
>
>    交换即，换出已经执行完毕或者挂起阻塞的进程，换入得到执行的进程

### 1.2 内存的分配方式

> 内存的分配方式可以分为2种：连续分配管理、非连续分配管理

#### 1.2.1 连续分配管理方式

> 连续分配，即为每个进程分配一个连续的物理内存空间。
> 
> 连续分配容易造成内存空间碎片化影响内存资源使用效率。

1. **单一连续分配**
   
   特点：
   
   - 分为系统区域和用户区域，低位地址区域多为系统区
   
   - 内存中永远只有一道程序，无需进行内存保护
   
   优点：
   
   - 简单
   
   - 无外部碎片
   
   - 可以直接采用覆盖的方式，无需额外的技术支持
   
   缺点：
   
   - 只能单用户、单任务
   
   - 有内部碎片
   
   - 内存利用率低下

2. **固定分区分配**
   
   特点：
   
   - 将用户区域分为多个分区，每个分区只分配给一道任务
   
   优点：
   
   * 可实现多道程序
   * 没有外部碎片
   
   缺点：
   
   * 可能存在程序过大，无法装载到任何分区
   * 可能会存在大量内部碎片
   
3. **动态分区分配（可变分区）**

   特点：

   - 不预先划分内存分区，而是在装载的时候根据进程大小进行划分

   优点：

   - 在最初开始分配的时候能够很好的利用空间
   - 没有内部碎片

   缺点：

   - 在运行一段时间后会产生大量的外部碎片
   - 需要进行紧凑操作，有额外的开销

   > **动态分配策略**:
   >
   > 1. 首次适应（First Fit）：
   >
   >    空闲分区以地址递增次序链接，按顺序找第一个可以装下的
   >
   > 2. 最佳适应（Best Fit）：
   >
   >    空闲分区按容量大小递增链接，按顺序找到第一个可以装下的
   >
   > 3. 最坏适应（Worst Fit）
   >
   >    空闲分区按照容量大小递减链接，按顺序找第一个可以装下的（即最大的）
   >
   > 4. 邻近适应（Next Fit）
   >
   >    循环首次适应，每次分配从上次查找结束的地方开始找

#### 1.2.2 非连续分配管理方式

> 非连续分配，即每个进程所分配的内存空间只是在逻辑上连续，在物理内存上可以是分散的

1. **简单分页式管理**

   **特点：**

   - 在分页管理中，每个进程拥有一个和机器RAM一样大的**逻辑地址空间**。
   - **程序**被分割成一个个很小的**页**（页的大小应当为2的整数次方），存储在**内存**中的**页框**中。
   - 程序的页在进程自己的逻辑地址中是连续的，但是在实际内存中可以是分散存储的，通过维护一个**页表**，来对应逻辑地址和物理地址。

   > 分页式管理，将一个程序分为多个页，且能够灵活的分散的存储到物理内存，<u>能够更好的利用内存空间</u>。
   >
   > 但是分页管理，<u>每次访问都需要进行逻辑地址和物理地址的转换，可能会降低速度</u>；
   >
   > <u>每个进程都有一个页表，如果页表过大，内存就都用来做页表了，使用率就降低了。</u>

   **快表：**

   > 由于分页式查询每次访问都需要进行地址转换，而访问步骤基本分为两步，即，先查页表找到物理地址，再去物理地址获取指令或者数据，这样通常会比较慢。
   >
   > 而引入快表是为了缩短这个过程，通过快表我们可以只查一次就找到需要的页框。

   - 快表是一种高速缓存（Cache）
   - 内容是页表中的一部分或全部内容。
   - 通常快表处于MMU中

2. **简单分段式管理**

   * 在分段式管理中，每个程序按照**自然段**划分，如一个程序包含一个主程序，两个子程序，我们可以分为3段（0，1，2）
   * 段的内存地址在段内是连续的，在段间可以是不连续的
   * 程序的段是原子的，要么都在内存里，要么都不在内存
   * 分段管理中，每个程序维护一个**段表**，段表（段号-段长-段起始地址），通过查询段表来确定段在内存中的位置

   > 分段管理更多的考虑了**程序编写的便捷性**、**信息的保护和共享**、**动态增长和链接**等需求

3. **段页式管理**

   > 页式存储有效的提高内存利用率，分段存储能够反映出程序的逻辑结构并有利于共享。将这两种管理办法结合起来便是段页式管理。

   * 段页式管理中，**程序**的地址空间首先被**分成**若干**逻辑段**，每段都有段号
   * 再**将每段分为**若干**页**，每段对应一个页表。

   即：

   - 每个程序有**一个段表** （段号-页表长度-页表开始地址）
   - 一个程序可以有多个页表，相应的**每个段有一个页表**（页号，块号）

## 2. 虚拟内存管理

